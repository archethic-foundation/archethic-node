commit 58458986e40e3609086d1f4911089dcdbfce91fa
Author: Samuel <samuel@uniris.io>
Date:   Wed Mar 9 16:11:40 2022 +0100

    Remove bucket from transaction chain schema

diff --git a/lib/archethic/db/cassandra_impl.ex b/lib/archethic/db/cassandra_impl.ex
index fab01ea..faf42cb 100644
--- a/lib/archethic/db/cassandra_impl.ex
+++ b/lib/archethic/db/cassandra_impl.ex
@@ -85,29 +85,17 @@ defmodule ArchEthic.DB.CassandraImpl do
     prepared =
       Xandra.prepare!(
         :xandra_conn,
-        "SELECT transaction_address FROM archethic.transaction_chains WHERE chain_address=? and bucket=?"
+        "SELECT transaction_address FROM archethic.transaction_chains WHERE chain_address=?"
       )
 
-    addresses_to_fetch =
-      1..4
-      |> Task.async_stream(
-        fn bucket ->
-          :xandra_conn
-          |> Xandra.stream_pages!(prepared, [address, bucket], page_size: 10)
-          |> Stream.flat_map(& &1)
-          |> Enum.map(fn %{"transaction_address" => tx_address} ->
-            tx_address
-          end)
-        end,
-        max_concurrency: 4
-      )
-      |> Enum.flat_map(fn {:ok, addresses} -> addresses end)
-
-    # Chunk the reads while leveraging concurrency
-    # avoiding a connection to be open too long to read many transactions
     chain =
-      addresses_to_fetch
-      |> Enum.chunk_every(10)
+      :xandra_conn
+      |> Xandra.stream_pages!(prepared, [address], page_size: 10)
+      |> Stream.map(fn rows ->
+        rows
+        |> Stream.map(&Map.get(&1, "transaction_address"))
+        |> Enum.to_list()
+      end)
       |> Task.async_stream(&chunk_get_transaction(&1, fields))
       |> Stream.filter(&match?({:ok, _}, &1))
       |> Stream.map(fn {:ok, transactions} -> transactions end)
@@ -298,12 +286,11 @@ defmodule ArchEthic.DB.CassandraImpl do
     prepared =
       Xandra.prepare!(
         conn,
-        "INSERT INTO archethic.transaction_chains(chain_address, bucket, transaction_address, transaction_timestamp) VALUES(?, ?, ?, ?)"
+        "INSERT INTO archethic.transaction_chains(chain_address, transaction_address, transaction_timestamp) VALUES(?, ?, ?)"
       )
 
     Xandra.execute!(conn, prepared, [
       chain_address,
-      bucket_from_date(tx_timestamp),
       tx_address,
       tx_timestamp
     ])
@@ -311,13 +298,9 @@ defmodule ArchEthic.DB.CassandraImpl do
     :ok
   end
 
-  defp bucket_from_date(%DateTime{month: month}) do
-    div(month + 2, 3)
-  end
-
   defp format_result_to_transaction(res) do
     res
-    |> Map.drop(["bucket", "chain_address", "timestamp"])
+    |> Map.drop(["chain_address", "timestamp"])
     |> Utils.atomize_keys(true)
     |> Transaction.from_map()
   end
@@ -364,22 +347,13 @@ defmodule ArchEthic.DB.CassandraImpl do
     prepared =
       Xandra.prepare!(
         :xandra_conn,
-        "SELECT COUNT(*) as size FROM archethic.transaction_chains WHERE chain_address=? and bucket=?"
+        "SELECT COUNT(*) as size FROM archethic.transaction_chains WHERE chain_address=?"
       )
 
-    Task.async_stream(
-      1..4,
-      fn bucket ->
-        :xandra_conn
-        |> Xandra.execute!(prepared, [address, bucket])
-        |> Enum.at(0, %{})
-        |> Map.get("size", 0)
-      end,
-      ordered: false
-    )
-    |> Enum.reduce(0, fn {:ok, size}, acc ->
-      acc + size
-    end)
+    :xandra_conn
+    |> Xandra.execute!(prepared, [address])
+    |> Enum.at(0, %{})
+    |> Map.get("size", 0)
   end
 
   @impl DB
diff --git a/priv/migrations/5_create_transaction_chains_table.cql b/priv/migrations/5_create_transaction_chains_table.cql
index 6146c7b..e8bdc04 100644
--- a/priv/migrations/5_create_transaction_chains_table.cql
+++ b/priv/migrations/5_create_transaction_chains_table.cql
@@ -1,9 +1,8 @@
 CREATE TABLE IF NOT EXISTS archethic.transaction_chains(
     chain_address blob,
-    bucket tinyint,
     transaction_address blob,
     transaction_timestamp timestamp,
-    PRIMARY KEY ((chain_address, bucket), transaction_timestamp)
+    PRIMARY KEY (chain_address, transaction_timestamp)
 )
 WITH CLUSTERING ORDER BY (transaction_timestamp DESC)
-AND COMPRESSION = { 'sstable_compression': 'LZ4Compressor' };
\ No newline at end of file
+AND COMPRESSION = { 'sstable_compression': 'LZ4Compressor' };
diff --git a/test/archethic/db/cassandra_impl_test.exs b/test/archethic/db/cassandra_impl_test.exs
index 7bd33a6..c364172 100644
--- a/test/archethic/db/cassandra_impl_test.exs
+++ b/test/archethic/db/cassandra_impl_test.exs
@@ -67,19 +67,14 @@ defmodule ArchEthic.DB.CassandraImplTest do
       chain_prepared_query =
         Xandra.prepare!(
           :xandra_conn,
-          "SELECT * FROM archethic.transaction_chains WHERE chain_address = ? and bucket = ?"
+          "SELECT * FROM archethic.transaction_chains WHERE chain_address = ?"
         )
 
       chain =
-        Task.async_stream(1..4, fn bucket ->
-          Xandra.execute!(:xandra_conn, chain_prepared_query, [
-            List.first(chain).address,
-            bucket
-          ])
-          |> Enum.to_list()
-        end)
-        |> Enum.map(fn {:ok, res} -> res end)
-        |> Enum.flat_map(& &1)
+        Xandra.execute!(:xandra_conn, chain_prepared_query, [
+          List.first(chain).address
+        ])
+        |> Enum.to_list()
 
       assert length(chain) == 2
     end
@@ -188,13 +183,21 @@ defmodule ArchEthic.DB.CassandraImplTest do
 
   test "get_transaction_chain/2 should retrieve the transaction chain with the requested fields" do
     chain = [
-      create_transaction(seed: "seed5", index: 1),
-      create_transaction(seed: "seed5", index: 0)
+      create_transaction(seed: "seed5", index: 1, timestamp: DateTime.utc_now()),
+      create_transaction(
+        seed: "seed5",
+        index: 0,
+        timestamp: DateTime.utc_now() |> DateTime.add(-86400)
+      )
     ]
 
     assert :ok = Cassandra.write_transaction_chain(chain)
-    chain = Cassandra.get_transaction_chain(List.first(chain).address, [:address, :type])
-    assert Enum.all?(chain, &([:address, :type] not in empty_keys(&1)))
+
+    assert received_chain =
+             Cassandra.get_transaction_chain(List.first(chain).address, [:address, :type])
+
+    assert Enum.map(received_chain, & &1.address) == Enum.map(chain, & &1.address)
+    assert Enum.all?(received_chain, &([:address, :type] not in empty_keys(&1)))
   end
 
   test "add_last_transaction_address/2 should reference a last address for a chain" do

